/*
 * Copyright (C) 2020-2024 ArtInChip Technology Co. Ltd
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Author: <che.jiang@artinchip.com>
 * Desc: advance streaming format parser, support wma and wmv formats
 */

#define LOG_TAG "asf"

#include "asf.h"
#include "aic_parser.h"
#include "aic_stream.h"
#include "aic_tag.h"
#include "aic_riff.h"
#include "mpp_log.h"
#include "mpp_mem.h"
#include <inttypes.h>
#include <stdlib.h>

#define ASF_TEMP_PKT_SIZE                     (256)
#define ASF_BOOL                              0x2
#define ASF_WORD                              0x5
#define ASF_GUID                              0x6
#define ASF_DWORD                             0x3
#define ASF_QWORD                             0x4
#define ASF_UNICODE                           0x0
#define ASF_FLAG_BROADCAST                    0x1
#define ASF_BYTE_ARRAY                        0x1
#define ASF_TYPE_AUDIO                        0x2
#define ASF_TYPE_VIDEO                        0x1
#define ASF_STREAM_NUM                        0x7F
#define ASF_MAX_STREAMS                       128
#define BMP_HEADER_SIZE                       40
#define ASF_NUM_OF_PAYLOADS                   0x3F
#define ASF_ERROR_CORRECTION_LENGTH_TYPE      0x60
#define ASF_PACKET_ERROR_CORRECTION_DATA_SIZE 0x2

#define ASF_PACKET_FLAG_ERROR_CORRECTION_PRESENT 0x80 // 1000 0000
// PPI_FLAG - Payload parsing information flags
#define ASF_PPI_FLAG_MULTIPLE_PAYLOADS_PRESENT 1

#define ASF_PPI_FLAG_SEQUENCE_FIELD_IS_BYTE   0x02    // 0000 0010
#define ASF_PPI_FLAG_SEQUENCE_FIELD_IS_WORD   0x04    // 0000 0100
#define ASF_PPI_FLAG_SEQUENCE_FIELD_IS_DWORD  0x06    // 0000 0110
#define ASF_PPI_MASK_SEQUENCE_FIELD_SIZE      0x06    // 0000 0110

#define ASF_PPI_FLAG_PADDING_LENGTH_FIELD_IS_BYTE  0x08  // 0000 1000
#define ASF_PPI_FLAG_PADDING_LENGTH_FIELD_IS_WORD  0x10  // 0001 0000
#define ASF_PPI_FLAG_PADDING_LENGTH_FIELD_IS_DWORD 0x18  // 0001 1000
#define ASF_PPI_MASK_PADDING_LENGTH_FIELD_SIZE     0x18  // 0001 1000

#define ASF_PPI_FLAG_PACKET_LENGTH_FIELD_IS_BYTE   0x20  // 0010 0000
#define ASF_PPI_FLAG_PACKET_LENGTH_FIELD_IS_WORD   0x40  // 0100 0000
#define ASF_PPI_FLAG_PACKET_LENGTH_FIELD_IS_DWORD  0x60  // 0110 0000
#define ASF_PPI_MASK_PACKET_LENGTH_FIELD_SIZE      0x60  // 0110 0000

// PL_FLAG - Payload flags
#define ASF_PL_FLAG_REPLICATED_DATA_LENGTH_FIELD_IS_BYTE 0x01  // 0000 0001
#define ASF_PL_FLAG_REPLICATED_DATA_LENGTH_FIELD_IS_WORD 0x02  // 0000 0010
#define ASF_PL_FLAG_REPLICATED_DATA_LENGTH_FIELD_IS_DWORD 0x03 // 0000 0011
#define ASF_PL_MASK_REPLICATED_DATA_LENGTH_FIELD_SIZE 0x03     // 0000 0011

#define ASF_PL_FLAG_OFFSET_INTO_MEDIA_OBJECT_LENGTH_FIELD_IS_BYTE 0x04  // 0000 0100
#define ASF_PL_FLAG_OFFSET_INTO_MEDIA_OBJECT_LENGTH_FIELD_IS_WORD 0x08  // 0000 1000
#define ASF_PL_FLAG_OFFSET_INTO_MEDIA_OBJECT_LENGTH_FIELD_IS_DWORD 0x0c // 0000 1100
#define ASF_PL_MASK_OFFSET_INTO_MEDIA_OBJECT_LENGTH_FIELD_SIZE 0x0c     // 0000 1100

#define ASF_PL_FLAG_MEDIA_OBJECT_NUMBER_LENGTH_FIELD_IS_BYTE 0x10  // 0001 0000
#define ASF_PL_FLAG_MEDIA_OBJECT_NUMBER_LENGTH_FIELD_IS_WORD 0x20  // 0010 0000
#define ASF_PL_FLAG_MEDIA_OBJECT_NUMBER_LENGTH_FIELD_IS_DWORD 0x30 // 0011 0000
#define ASF_PL_MASK_MEDIA_OBJECT_NUMBER_LENGTH_FIELD_SIZE 0x30     // 0011 0000

#define ASF_PL_FLAG_STREAM_NUMBER_LENGTH_FIELD_IS_BYTE 0x40 // 0100 0000
#define ASF_PL_MASK_STREAM_NUMBER_LENGTH_FIELD_SIZE 0xc0    // 1100 0000

#define ASF_PL_FLAG_PAYLOAD_LENGTH_FIELD_IS_BYTE 0x40 // 0100 0000
#define ASF_PL_FLAG_PAYLOAD_LENGTH_FIELD_IS_WORD 0x80 // 1000 0000
#define ASF_PL_MASK_PAYLOAD_LENGTH_FIELD_SIZE 0xc0    // 1100 0000


#define ASF_READ_LEN(flag, name, len)      \
    do {                                   \
        if ((flag) == name##IS_BYTE)       \
            len = aic_stream_r8(pb);       \
        else if ((flag) == name##IS_WORD)  \
            len = aic_stream_rl16(pb);     \
        else if ((flag) == name##IS_DWORD) \
            len = aic_stream_rl32(pb);     \
        else                               \
            len = 0;                       \
    } while (0)

typedef uint8_t asf_guid[16];

typedef struct asf_main_header {
    asf_guid guid;        ///< generated by client computer
    uint64_t file_size;   /* in bytes invalid if broadcasting */
    uint64_t create_time; /* time of creation, in 100-nanosecond units */
    uint64_t play_time;   /* play time, in 100-nanosecond units */
    uint64_t send_time;   /* time to send file*/
    uint32_t preroll;     /* timestamp of the first packet, in milliseconds */
    uint32_t ignore;      /* preroll is 64 bits - but let's just ignore it */
    uint32_t flags;       /* 0x01 - broadcast, 0x02 - seekable, other 0 */
    uint32_t min_pktsize; /* size of a data packet */
    uint32_t max_pktsize; /* shall be the same as for min_pktsize */
    uint32_t max_bitrate; /* bandwidth of stream in bps */
} asf_main_header;

typedef struct asf_index {
    uint32_t packet_number;
    uint16_t packet_count;
    uint64_t send_time;
    uint64_t offset;
} asf_index;

typedef struct guid_parser_table {
    const char *name;
    asf_guid guid;
    int (*read_object)(struct aic_asf_parser *, const struct guid_parser_table *);
    int is_subobject;
} guid_parser_table;

typedef struct asf_packet {
    struct aic_parser_packet avpkt;
    int64_t dts;
    uint32_t frame_num; // ASF payloads with the same number are parts of the same frame
    int flag;
    int data_size;
    int duration;
    int size_left;
    uint8_t stream_index;
} asf_packet;

typedef struct asf_stream {
    uint8_t stream_index; // from packet header
    int index;            // stream index in struct aic_asf_parser, set in asf_read_stream_properties
    int type;
    int indexed; // added index entries from the Simple Index Object or not
    int8_t span; // for deinterleasfng
    uint16_t virtual_pkt_len;
    uint16_t virtual_chunk_len;
    int16_t lang_idx;
    asf_packet pkt;
} asf_stream;

typedef struct asf_context {
    int data_reached;
    int is_simple_index; // is simple index present or not 1/0
    int is_header;
    int is_end_packet;
    uint64_t preroll;
    uint64_t nb_packets; // ASF packets
    uint64_t nb_cur_packets; // ASF current packets
    uint32_t packet_size;
    int duration;
    int64_t send_time;
    uint64_t create_time;
    uint32_t b_flags;    // flags with broadcast flag
    uint32_t prop_flags; // file properties object flags

    uint64_t data_size;    // data object size
    uint64_t unknown_size; // size of the unknown object

    int64_t offset; // offset of the current object

    int64_t data_offset;
    int64_t first_packet_offset; // packet offset
    int64_t unknown_offset;      // for top level header objects or subobjects without specified behasfor

    // ASF file must not contain more than 128 streams according to the specification
    asf_stream *asf_st[ASF_MAX_STREAMS];
    int nb_streams;

    int stream_index; // from packet header, for the subpayload case

    // packet parameters
    uint64_t sub_header_offset; // offset of subpayload header
    int64_t sub_dts;
    uint8_t dts_delta;             // for subpayloads
    uint32_t seq;
    uint32_t packet_size_internal; // packet size stored inside asf_packet, can be 0
    int64_t packet_offset;         // offset of the current packet inside Data Object
    uint32_t pad_len;              // padding after payload
    uint32_t rep_data_len;

    // packet state
    uint64_t sub_left;     // subpayloads left or not
    unsigned int nb_sub;   // number of subpayloads read so far from the current ASF packet
    uint16_t mult_sub_len; // total length of subpayloads array inside multiple payload
    uint64_t nb_mult_left; // multiple payloads left
    int return_subpayload;
    enum {
        PARSE_PACKET_HEADER,
        READ_SINGLE,
        READ_MULTI,
        READ_MULTI_SUB
    } state;
    struct aic_parser_packet cur_pkt;
} asf_context;

const asf_guid g_asf_header = {
    0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C};

const asf_guid g_asf_file_header = {
    0xA1, 0xDC, 0xAB, 0x8C, 0x47, 0xA9, 0xCF, 0x11, 0x8E, 0xE4, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65};

const asf_guid g_asf_stream_header = {
    0x91, 0x07, 0xDC, 0xB7, 0xB7, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65};

const asf_guid g_asf_ext_stream_header = {
    0xCB, 0xA5, 0xE6, 0x14, 0x72, 0xC6, 0x32, 0x43, 0x83, 0x99, 0xA9, 0x69, 0x52, 0x06, 0x5B, 0x5A};

const asf_guid g_asf_audio_stream = {
    0x40, 0x9E, 0x69, 0xF8, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B};

const asf_guid g_asf_audio_conceal_none = {
    // 0x40, 0xa4, 0xf1, 0x49, 0x4ece, 0x11d0, 0xa3, 0xac, 0x00, 0xa0, 0xc9, 0x03, 0x48, 0xf6
    // New value lifted from asffile
    0x00, 0x57, 0xfb, 0x20, 0x55, 0x5B, 0xCF, 0x11, 0xa8, 0xfd, 0x00, 0x80, 0x5f, 0x5c, 0x44, 0x2b};

const asf_guid g_asf_audio_conceal_spread = {
    0x50, 0xCD, 0xC3, 0xBF, 0x8F, 0x61, 0xCF, 0x11, 0x8B, 0xB2, 0x00, 0xAA, 0x00, 0xB4, 0xE2, 0x20};

const asf_guid g_asf_video_stream = {
    0xC0, 0xEF, 0x19, 0xBC, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B};

const asf_guid g_asf_jfif_media = {
    0x00, 0xE1, 0x1B, 0xB6, 0x4E, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B};

const asf_guid g_asf_video_conceal_none = {
    0x00, 0x57, 0xFB, 0x20, 0x55, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B};

const asf_guid g_asf_command_stream = {
    0xC0, 0xCF, 0xDA, 0x59, 0xE6, 0x59, 0xD0, 0x11, 0xA3, 0xAC, 0x00, 0xA0, 0xC9, 0x03, 0x48, 0xF6};

const asf_guid g_asf_comment_header = {
    0x33, 0x26, 0xb2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xa6, 0xd9, 0x00, 0xaa, 0x00, 0x62, 0xce, 0x6c};

const asf_guid g_asf_codec_comment_header = {
    0x40, 0x52, 0xD1, 0x86, 0x1D, 0x31, 0xD0, 0x11, 0xA3, 0xA4, 0x00, 0xA0, 0xC9, 0x03, 0x48, 0xF6};
const asf_guid g_asf_codec_comment1_header = {
    0x41, 0x52, 0xd1, 0x86, 0x1D, 0x31, 0xD0, 0x11, 0xa3, 0xa4, 0x00, 0xa0, 0xc9, 0x03, 0x48, 0xf6};

const asf_guid g_asf_data_header = {
    0x36, 0x26, 0xb2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xa6, 0xd9, 0x00, 0xaa, 0x00, 0x62, 0xce, 0x6c};

const asf_guid g_asf_head1_guid = {
    0xb5, 0x03, 0xbf, 0x5f, 0x2E, 0xA9, 0xCF, 0x11, 0x8e, 0xe3, 0x00, 0xc0, 0x0c, 0x20, 0x53, 0x65};

const asf_guid g_asf_head2_guid = {
    0x11, 0xd2, 0xd3, 0xab, 0xBA, 0xA9, 0xCF, 0x11, 0x8e, 0xe6, 0x00, 0xc0, 0x0c, 0x20, 0x53, 0x65};

const asf_guid g_asf_extended_content_header = {
    0x40, 0xA4, 0xD0, 0xD2, 0x07, 0xE3, 0xD2, 0x11, 0x97, 0xF0, 0x00, 0xA0, 0xC9, 0x5E, 0xA8, 0x50};

const asf_guid g_asf_simple_index_header = {
    0x90, 0x08, 0x00, 0x33, 0xB1, 0xE5, 0xCF, 0x11, 0x89, 0xF4, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xCB};

const asf_guid g_asf_ext_stream_embed_stream_header = {
    0xe2, 0x65, 0xfb, 0x3a, 0xEF, 0x47, 0xF2, 0x40, 0xac, 0x2c, 0x70, 0xa9, 0x0d, 0x71, 0xd3, 0x43};

const asf_guid g_asf_ext_stream_audio_stream = {
    0x9d, 0x8c, 0x17, 0x31, 0xE1, 0x03, 0x28, 0x45, 0xb5, 0x82, 0x3d, 0xf9, 0xdb, 0x22, 0xf5, 0x03};

const asf_guid g_asf_metadata_header = {
    0xea, 0xcb, 0xf8, 0xc5, 0xaf, 0x5b, 0x77, 0x48, 0x84, 0x67, 0xaa, 0x8c, 0x44, 0xfa, 0x4c, 0xca};

const asf_guid g_asf_metadata_library_header = {
    0x94, 0x1c, 0x23, 0x44, 0x98, 0x94, 0xd1, 0x49, 0xa1, 0x41, 0x1d, 0x13, 0x4e, 0x45, 0x70, 0x54};

const asf_guid g_asf_marker_header = {
    0x01, 0xCD, 0x87, 0xF4, 0x51, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65};

const asf_guid g_asf_reserved_4 = {
    0x20, 0xdb, 0xfe, 0x4c, 0xf6, 0x75, 0xCF, 0x11, 0x9c, 0x0f, 0x00, 0xa0, 0xc9, 0x03, 0x49, 0xcb};

/* I am not a number !!! This GUID is the one found on the PC used to
 * generate the stream */
const asf_guid g_asf_my_guid = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

const asf_guid g_asf_language_guid = {
    0xa9, 0x46, 0x43, 0x7c, 0xe0, 0xef, 0xfc, 0x4b, 0xb2, 0x29, 0x39, 0x3e, 0xde, 0x41, 0x5c, 0x85};

const asf_guid g_asf_content_encryption = {
    0xfb, 0xb3, 0x11, 0x22, 0x23, 0xbd, 0xd2, 0x11, 0xb4, 0xb7, 0x00, 0xa0, 0xc9, 0x55, 0xfc, 0x6e};

const asf_guid g_asf_ext_content_encryption = {
    0x14, 0xe6, 0x8a, 0x29, 0x22, 0x26, 0x17, 0x4c, 0xb9, 0x35, 0xda, 0xe0, 0x7e, 0xe9, 0x28, 0x9c};

const asf_guid g_asf_digital_signature = {
    0xfc, 0xb3, 0x11, 0x22, 0x23, 0xbd, 0xd2, 0x11, 0xb4, 0xb7, 0x00, 0xa0, 0xc9, 0x55, 0xfc, 0x6e};

const asf_guid g_asf_extended_stream_properties_object = {
    0xcb, 0xa5, 0xe6, 0x14, 0x72, 0xc6, 0x32, 0x43, 0x83, 0x99, 0xa9, 0x69, 0x52, 0x06, 0x5b, 0x5a};

const asf_guid g_asf_group_mutual_exclusion_object = {
    0x40, 0x5a, 0x46, 0xd1, 0x79, 0x5a, 0x38, 0x43, 0xb7, 0x1b, 0xe3, 0x6b, 0x8f, 0xd6, 0xc2, 0x49};

const asf_guid g_asf_mutex_language = {
    0x00, 0x2a, 0xe2, 0xd6, 0xda, 0x35, 0xd1, 0x11, 0x90, 0x34, 0x00, 0xa0, 0xc9, 0x03, 0x49, 0xbe};


static int detect_unknown_subobject(struct aic_asf_parser *s, int64_t offset, int64_t size);
static const guid_parser_table *find_guid(asf_guid guid);

static void asf_swap_guid(asf_guid guid)
{
    MPP_SWAP(unsigned char, guid[0], guid[3]);
    MPP_SWAP(unsigned char, guid[1], guid[2]);
    MPP_SWAP(unsigned char, guid[4], guid[5]);
    MPP_SWAP(unsigned char, guid[6], guid[7]);
}

int asf_get_guid(struct aic_stream *pb, asf_guid *g)
{
    int ret;
    mpp_assert(sizeof(*g) == 16); //compiler will optimize this out
    ret = aic_stream_read(pb, *g, sizeof(*g));
    if (ret < (int)sizeof(*g)) {
        memset(*g, 0, sizeof(*g));
        return ret < 0 ? ret : PARSER_INVALIDDATA;
    }
    return 0;
}

static void align_position(struct aic_stream *pb, int64_t offset, uint64_t size)
{
    if (size < INT64_MAX - offset && aic_stream_tell(pb) != offset + size)
        aic_stream_seek(pb, offset + size, SEEK_SET);
}

static int asf_read_unknown(struct aic_asf_parser *s, const guid_parser_table *g)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    uint64_t size = aic_stream_rl64(pb);
    int ret;

    if (size > INT64_MAX)
        return PARSER_INVALIDDATA;

    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, "Header Extension")))
            aic_stream_skip(pb, 22); // skip reserved fields and Data Size
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return PARSER_ERROR;
    } else {
        if (size < 24) {
            loge("Too small size %" PRIu64 " (< 24).\n", size);
            return PARSER_INVALIDDATA;
        }
        aic_stream_skip(pb, size - 24);
    }

    return PARSER_OK;
}


static int asf_read_marker(struct aic_asf_parser *s, const guid_parser_table *g)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    uint64_t size = aic_stream_rl64(pb);
    align_position(pb, asf->offset, size);
    return PARSER_OK;
}


static int asf_read_ext_content(struct aic_asf_parser *s, const guid_parser_table *g)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    uint64_t size = aic_stream_rl64(pb);
    align_position(pb, asf->offset, size);
    return PARSER_OK;
}

static struct asf_stream_ctx *asf_new_stream(struct aic_asf_parser *s)
{
    struct asf_stream_ctx *sc;

    sc = (struct asf_stream_ctx *)mpp_alloc(sizeof(struct asf_stream_ctx));
    if (sc == NULL) {
        return NULL;
    }
    memset(sc, 0, sizeof(struct asf_stream_ctx));

    sc->index = s->nb_streams;
    s->streams[s->nb_streams++] = sc;

    return sc;
}

static int asf_read_metadata_obj(struct aic_asf_parser *s, const guid_parser_table *g)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    uint64_t size = aic_stream_rl64(pb);
    align_position(pb, asf->offset, size);
    return PARSER_OK;
}

static int asf_read_content_desc(struct aic_asf_parser *s, const guid_parser_table *g)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    uint64_t size = aic_stream_rl64(pb);
    align_position(pb, asf->offset, size);
    return PARSER_OK;
}

static int asf_read_properties(struct aic_asf_parser *s, const guid_parser_table *g)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;

    aic_stream_rl64(pb);     // read object size
    aic_stream_skip(pb, 16); // skip File ID
    aic_stream_skip(pb, 8);  // skip File size
    asf->create_time = aic_stream_rl64(pb);
    asf->nb_packets = aic_stream_rl64(pb);
    asf->duration = aic_stream_rl64(pb) / 10000; // stream duration
    aic_stream_skip(pb, 8);                      // skip send duration
    asf->preroll = aic_stream_rl64(pb);
    asf->duration -= asf->preroll;
    asf->b_flags = aic_stream_rl32(pb);
    aic_stream_skip(pb, 4); // skip minimal packet size
    asf->packet_size = aic_stream_rl32(pb);
    aic_stream_skip(pb, 4); // skip max_bitrate

    return PARSER_OK;
}

static int parse_video_info(struct aic_stream *pb, struct asf_stream_ctx *st)
{
    uint32_t tag;
    uint32_t size_bmp; // BMP_HEADER-specific Format Data size

    st->codecpar.width = aic_stream_rl32(pb);
    st->codecpar.height = aic_stream_rl32(pb);
    aic_stream_skip(pb, 1); // skip reserved flags
    aic_stream_rl16(pb);
    tag = aic_get_bmp_header(pb, &st->codecpar, (unsigned int*)&size_bmp);
    st->codecpar.codec_tag = tag;
    st->codecpar.codec_id = aic_codec_get_id(aic_codec_bmp_tags, tag);

    return PARSER_OK;
}


static int asf_read_stream_properties(struct aic_asf_parser *s, const guid_parser_table *g)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    uint64_t size;
    uint32_t err_data_len, ts_data_len; // type specific data length
    uint16_t flags;
    asf_guid stream_type;
    enum aic_stream_type type;
    int i, ret;
    uint8_t stream_index;
    struct asf_stream_ctx *st;
    asf_stream *asf_st;

    // ASF file must not contain more than 128 streams according to the specification
    if (asf->nb_streams >= ASF_MAX_STREAMS)
        return PARSER_INVALIDDATA;

    size = aic_stream_rl64(pb);
    asf_get_guid(pb, &stream_type);
    if (!memcmp(&stream_type, &g_asf_audio_stream, sizeof(asf_guid)))
        type = MPP_MEDIA_TYPE_AUDIO;
    else if (!memcmp(&stream_type, &g_asf_video_stream, sizeof(asf_guid)))
        type = MPP_MEDIA_TYPE_VIDEO;
    else if (!memcmp(&stream_type, &g_asf_jfif_media, sizeof(asf_guid)))
        type = MPP_MEDIA_TYPE_VIDEO;
    else
        return PARSER_INVALIDDATA;

    asf_get_guid(pb, &stream_type); // error correction type
    aic_stream_skip(pb, 8);        // skip the time offset
    ts_data_len = aic_stream_rl32(pb);
    err_data_len = aic_stream_rl32(pb);
    flags = aic_stream_rl16(pb); // bit 15 - Encrypted Content

    stream_index = flags & ASF_STREAM_NUM;
    for (i = 0; i < asf->nb_streams; i++)
        if (stream_index == asf->asf_st[i]->stream_index) {
            logw("Duplicate stream found, this stream will be ignored.\n");
            align_position(pb, asf->offset, size);
            return PARSER_OK;
        }

    st = asf_new_stream(s);
    if (!st)
        return PARSER_NOMEM;
    st->codecpar.codec_type = type;
    asf->asf_st[asf->nb_streams] = mpp_alloc(sizeof(*asf_st));
    if (!asf->asf_st[asf->nb_streams])
        return PARSER_NOMEM;
    asf_st = asf->asf_st[asf->nb_streams];
    asf->nb_streams++;
    asf_st->stream_index = stream_index;
    asf_st->index = st->index;
    asf_st->indexed = 0;
    st->id = flags & ASF_STREAM_NUM;
    memset(&asf_st->pkt.avpkt, 0, sizeof(struct aic_parser_packet));
    asf_st->pkt.avpkt.size = 0;
    asf_st->pkt.avpkt.type = type;

    aic_stream_skip(pb, 4); // skip reserved field

    switch (type) {
    case MPP_MEDIA_TYPE_AUDIO:
        asf_st->type = MPP_MEDIA_TYPE_AUDIO;
        if ((ret = aic_get_wav_header(pb, &st->codecpar, ts_data_len, 0, 1)) < 0)
            return PARSER_ERROR;
        break;
    case MPP_MEDIA_TYPE_VIDEO:
        asf_st->type = MPP_MEDIA_TYPE_VIDEO;
        if ((ret = parse_video_info(pb, st)) < 0)
            return PARSER_ERROR;
        break;
    default:
        aic_stream_skip(pb, ts_data_len);
        break;
    }

    if (err_data_len) {
        if (type == MPP_MEDIA_TYPE_AUDIO) {
            uint8_t span = aic_stream_r8(pb);
            if (span > 1) {
                asf_st->span = span;
                asf_st->virtual_pkt_len = aic_stream_rl16(pb);
                asf_st->virtual_chunk_len = aic_stream_rl16(pb);
                if (!asf_st->virtual_chunk_len || !asf_st->virtual_pkt_len)
                    return PARSER_INVALIDDATA;
                aic_stream_skip(pb, err_data_len - 5);
            } else {
                aic_stream_skip(pb, err_data_len - 1);
            }
        } else {
            aic_stream_skip(pb, err_data_len);
        }
    }

    align_position(pb, asf->offset, size);

    return PARSER_OK;
}


static int asf_read_ext_stream_properties(struct aic_asf_parser *s, const guid_parser_table *g)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    struct asf_stream_ctx *st = NULL;
    asf_guid guid;
    uint16_t nb_st_name, nb_pay_exts, st_num, lang_idx;
    int i, ret;
    uint32_t bitrate;
    uint64_t start_time, end_time;
    uint64_t size = aic_stream_rl64(pb);

    start_time = aic_stream_rl64(pb);
    end_time = aic_stream_rl64(pb);
    bitrate = aic_stream_rl32(pb);
    aic_stream_skip(pb, 28); // skip some unused values
    st_num = aic_stream_rl16(pb);
    st_num &= ASF_STREAM_NUM;
    lang_idx = aic_stream_rl16(pb); // Stream Language ID Index
    for (i = 0; i < asf->nb_streams; i++) {
        if (st_num == asf->asf_st[i]->stream_index) {
            st = s->streams[asf->asf_st[i]->index];
            asf->asf_st[i]->lang_idx = lang_idx;
            break;
        }
    }
    aic_stream_skip(pb, 8); // average time per frame
    if (st) {
        st->start_time = start_time;
        st->duration = end_time - start_time;
        st->codecpar.bit_rate = bitrate;
    }
    nb_st_name = aic_stream_rl16(pb);
    nb_pay_exts = aic_stream_rl16(pb);
    for (i = 0; i < nb_st_name; i++) {
        uint16_t len;

        aic_stream_rl16(pb); // Language ID Index
        len = aic_stream_rl16(pb);
        aic_stream_skip(pb, len);
    }

    for (i = 0; i < nb_pay_exts; i++) {
        uint32_t len;
        aic_stream_skip(pb, 16); // Extension System ID
        aic_stream_skip(pb, 2);  // Extension Data Size
        len = aic_stream_rl32(pb);
        aic_stream_skip(pb, len);
    }

    if ((ret = asf_get_guid(pb, &guid)) < 0) {
        align_position(pb, asf->offset, size);

        return 0;
    }

    g = find_guid(guid);
    if (g && !(strcmp(g->name, "Stream Properties"))) {
        if ((ret = g->read_object(s, g)) < 0)
            return PARSER_ERROR;
    }

    align_position(pb, asf->offset, size);
    return PARSER_OK;
}

static int asf_read_language_list(struct aic_asf_parser *s, const guid_parser_table *g)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    uint64_t size = aic_stream_rl64(pb);
    align_position(pb, asf->offset, size);
    return 0;
}

// returns data object offset when reading this object for the first time
static int asf_read_data(struct aic_asf_parser *s, const guid_parser_table *g)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    uint64_t size = asf->data_size = aic_stream_rl64(pb);
    int i;

    if (!asf->data_reached) {
        asf->data_reached = 1;
        asf->data_offset = asf->offset;
    }

    for (i = 0; i < asf->nb_streams; i++) {
        if (!(asf->b_flags & ASF_FLAG_BROADCAST))
            s->streams[i]->duration = asf->duration;
    }
    asf->nb_mult_left = 0;
    asf->sub_left = 0;
    asf->state = PARSE_PACKET_HEADER;
    asf->return_subpayload = 0;
    asf->packet_size_internal = 0;
    aic_stream_skip(pb, 16);    // skip File ID
    size = aic_stream_rl64(pb); // Total Data Packets
    if (size != asf->nb_packets)
        logw("Number of Packets from File Properties Object is not equal to Total"
             "Datapackets value! num of packets %" PRIu64 " total num %" PRIu64 ".\n",
             size, asf->nb_packets);
    aic_stream_skip(pb, 2); // skip reserved field
    asf->first_packet_offset = aic_stream_tell(pb);

    return 0;
}

static int asf_read_simple_index(struct aic_asf_parser *s, const guid_parser_table *g)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    uint64_t size = aic_stream_rl64(pb);

    align_position(pb, asf->offset, size);

    return 0;
}

static const guid_parser_table gdef[] = {
    {"Data", {0x75, 0xB2, 0x26, 0x36, 0x66, 0x8E, 0x11, 0xCF, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C}, asf_read_data, 1},
    {"Simple Index", {0x33, 0x00, 0x08, 0x90, 0xE5, 0xB1, 0x11, 0xCF, 0x89, 0xF4, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xCB}, asf_read_simple_index, 1},
    {"Content Description", {0x75, 0xB2, 0x26, 0x33, 0x66, 0x8E, 0x11, 0xCF, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C}, asf_read_content_desc, 1},
    {"Extended Content Description", {0xD2, 0xD0, 0xA4, 0x40, 0xE3, 0x07, 0x11, 0xD2, 0x97, 0xF0, 0x00, 0xA0, 0xC9, 0x5e, 0xA8, 0x50}, asf_read_ext_content, 1},
    {"Stream Bitrate Properties", {0x7B, 0xF8, 0x75, 0xCE, 0x46, 0x8D, 0x11, 0xD1, 0x8D, 0x82, 0x00, 0x60, 0x97, 0xC9, 0xA2, 0xB2}, asf_read_unknown, 1},
    {"File Properties", {0x8C, 0xAB, 0xDC, 0xA1, 0xA9, 0x47, 0x11, 0xCF, 0x8E, 0xE4, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65}, asf_read_properties, 1},
    {"Header Extension", {0x5F, 0xBF, 0x03, 0xB5, 0xA9, 0x2E, 0x11, 0xCF, 0x8E, 0xE3, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65}, asf_read_unknown, 0},
    {"Stream Properties", {0xB7, 0xDC, 0x07, 0x91, 0xA9, 0xB7, 0x11, 0xCF, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65}, asf_read_stream_properties, 1},
    {"Codec List", {0x86, 0xD1, 0x52, 0x40, 0x31, 0x1D, 0x11, 0xD0, 0xA3, 0xA4, 0x00, 0xA0, 0xC9, 0x03, 0x48, 0xF6}, asf_read_unknown, 1},
    {"Marker", {0xF4, 0x87, 0xCD, 0x01, 0xA9, 0x51, 0x11, 0xCF, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65}, asf_read_marker, 1},
    {"Script Command", {0x1E, 0xFB, 0x1A, 0x30, 0x0B, 0x62, 0x11, 0xD0, 0xA3, 0x9B, 0x00, 0xA0, 0xC9, 0x03, 0x48, 0xF6}, asf_read_unknown, 1},
    {"Language List", {0x7C, 0x43, 0x46, 0xa9, 0xef, 0xe0, 0x4B, 0xFC, 0xB2, 0x29, 0x39, 0x3e, 0xde, 0x41, 0x5c, 0x85}, asf_read_language_list, 1},
    {"Padding", {0x18, 0x06, 0xD4, 0x74, 0xCA, 0xDF, 0x45, 0x09, 0xA4, 0xBA, 0x9A, 0xAB, 0xCB, 0x96, 0xAA, 0xE8}, asf_read_unknown, 1},
    {"DRMv1 Header", {0x22, 0x11, 0xB3, 0xFB, 0xBD, 0x23, 0x11, 0xD2, 0xB4, 0xB7, 0x00, 0xA0, 0xC9, 0x55, 0xFC, 0x6E}, asf_read_unknown, 1},
    {"DRMv2 Header", {0x29, 0x8A, 0xE6, 0x14, 0x26, 0x22, 0x4C, 0x17, 0xB9, 0x35, 0xDA, 0xE0, 0x7E, 0xE9, 0x28, 0x9c}, asf_read_unknown, 1},
    {"Index", {0xD6, 0xE2, 0x29, 0xD3, 0x35, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE}, asf_read_unknown, 1},
    {"Media Object Index", {0xFE, 0xB1, 0x03, 0xF8, 0x12, 0xAD, 0x4C, 0x64, 0x84, 0x0F, 0x2A, 0x1D, 0x2F, 0x7A, 0xD4, 0x8C}, asf_read_unknown, 1},
    {"Timecode Index", {0x3C, 0xB7, 0x3F, 0xD0, 0x0C, 0x4A, 0x48, 0x03, 0x95, 0x3D, 0xED, 0xF7, 0xB6, 0x22, 0x8F, 0x0C}, asf_read_unknown, 0},
    {"Bitrate_Mutual_Exclusion", {0xD6, 0xE2, 0x29, 0xDC, 0x35, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE}, asf_read_unknown, 1},
    {"Error Correction", {0x75, 0xB2, 0x26, 0x35, 0x66, 0x8E, 0x11, 0xCF, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C}, asf_read_unknown, 1},
    {"Content Branding", {0x22, 0x11, 0xB3, 0xFA, 0xBD, 0x23, 0x11, 0xD2, 0xB4, 0xB7, 0x00, 0xA0, 0xC9, 0x55, 0xFC, 0x6E}, asf_read_unknown, 1},
    {"Content Encryption", {0x22, 0x11, 0xB3, 0xFB, 0xBD, 0x23, 0x11, 0xD2, 0xB4, 0xB7, 0x00, 0xA0, 0xC9, 0x55, 0xFC, 0x6E}, asf_read_unknown, 1},
    {"Extended Content Encryption", {0x29, 0x8A, 0xE6, 0x14, 0x26, 0x22, 0x4C, 0x17, 0xB9, 0x35, 0xDA, 0xE0, 0x7E, 0xE9, 0x28, 0x9C}, asf_read_unknown, 1},
    {"Digital Signature", {0x22, 0x11, 0xB3, 0xFC, 0xBD, 0x23, 0x11, 0xD2, 0xB4, 0xB7, 0x00, 0xA0, 0xC9, 0x55, 0xFC, 0x6E}, asf_read_unknown, 1},
    {"Extended Stream Properties", {0x14, 0xE6, 0xA5, 0xCB, 0xC6, 0x72, 0x43, 0x32, 0x83, 0x99, 0xA9, 0x69, 0x52, 0x06, 0x5B, 0x5A}, asf_read_ext_stream_properties, 1},
    {"Advanced Mutual Exclusion", {0xA0, 0x86, 0x49, 0xCF, 0x47, 0x75, 0x46, 0x70, 0x8A, 0x16, 0x6E, 0x35, 0x35, 0x75, 0x66, 0xCD}, asf_read_unknown, 1},
    {"Group Mutual Exclusion", {0xD1, 0x46, 0x5A, 0x40, 0x5A, 0x79, 0x43, 0x38, 0xB7, 0x1B, 0xE3, 0x6B, 0x8F, 0xD6, 0xC2, 0x49}, asf_read_unknown, 1},
    {"Stream Prioritization", {0xD4, 0xFE, 0xD1, 0x5B, 0x88, 0xD3, 0x45, 0x4F, 0x81, 0xF0, 0xED, 0x5C, 0x45, 0x99, 0x9E, 0x24}, asf_read_unknown, 1},
    {"Bandwidth Sharing Object", {0xA6, 0x96, 0x09, 0xE6, 0x51, 0x7B, 0x11, 0xD2, 0xB6, 0xAF, 0x00, 0xC0, 0x4F, 0xD9, 0x08, 0xE9}, asf_read_unknown, 1},
    {"Metadata", {0xC5, 0xF8, 0xCB, 0xEA, 0x5B, 0xAF, 0x48, 0x77, 0x84, 0x67, 0xAA, 0x8C, 0x44, 0xFA, 0x4C, 0xCA}, asf_read_metadata_obj, 1},
    {"Metadata Library", {0x44, 0x23, 0x1C, 0x94, 0x94, 0x98, 0x49, 0xD1, 0xA1, 0x41, 0x1D, 0x13, 0x4E, 0x45, 0x70, 0x54}, asf_read_metadata_obj, 1},
    {"Audio Spread", {0xBF, 0xC3, 0xCD, 0x50, 0x61, 0x8F, 0x11, 0xCF, 0x8B, 0xB2, 0x00, 0xAA, 0x00, 0xB4, 0xE2, 0x20}, asf_read_unknown, 1},
    {"Index Parameters", {0xD6, 0xE2, 0x29, 0xDF, 0x35, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE}, asf_read_unknown, 1},
    {"Content Encryption System Windows Media DRM Network Devices", {0x7A, 0x07, 0x9B, 0xB6, 0xDA, 0XA4, 0x4e, 0x12, 0xA5, 0xCA, 0x91, 0xD3, 0x8D, 0xC1, 0x1A, 0x8D}, asf_read_unknown, 1},
    {"Mutex Language", {0xD6, 0xE2, 0x2A, 0x00, 0x25, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE}, asf_read_unknown, 1},
    {"Mutex Bitrate", {0xD6, 0xE2, 0x2A, 0x01, 0x25, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE}, asf_read_unknown, 1},
    {"Mutex Unknown", {0xD6, 0xE2, 0x2A, 0x02, 0x25, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE}, asf_read_unknown, 1},
    {"Bandwidth Sharing Exclusive", {0xAF, 0x60, 0x60, 0xAA, 0x51, 0x97, 0x11, 0xD2, 0xB6, 0xAF, 0x00, 0xC0, 0x4F, 0xD9, 0x08, 0xE9}, asf_read_unknown, 1},
    {"Bandwidth Sharing Partial", {0xAF, 0x60, 0x60, 0xAB, 0x51, 0x97, 0x11, 0xD2, 0xB6, 0xAF, 0x00, 0xC0, 0x4F, 0xD9, 0x08, 0xE9}, asf_read_unknown, 1},
    {"Payload Extension System Timecode", {0x39, 0x95, 0x95, 0xEC, 0x86, 0x67, 0x4E, 0x2D, 0x8F, 0xDB, 0x98, 0x81, 0x4C, 0xE7, 0x6C, 0x1E}, asf_read_unknown, 1},
    {"Payload Extension System File Name", {0xE1, 0x65, 0xEC, 0x0E, 0x19, 0xED, 0x45, 0xD7, 0xB4, 0xA7, 0x25, 0xCB, 0xD1, 0xE2, 0x8E, 0x9B}, asf_read_unknown, 1},
    {"Payload Extension System Content Type", {0xD5, 0x90, 0xDC, 0x20, 0x07, 0xBC, 0x43, 0x6C, 0x9C, 0xF7, 0xF3, 0xBB, 0xFB, 0xF1, 0xA4, 0xDC}, asf_read_unknown, 1},
    {"Payload Extension System Pixel Aspect Ratio", {0x1, 0x1E, 0xE5, 0x54, 0xF9, 0xEA, 0x4B, 0xC8, 0x82, 0x1A, 0x37, 0x6B, 0x74, 0xE4, 0xC4, 0xB8}, asf_read_unknown, 1},
    {"Payload Extension System Sample Duration", {0xC6, 0xBD, 0x94, 0x50, 0x86, 0x7F, 0x49, 0x07, 0x83, 0xA3, 0xC7, 0x79, 0x21, 0xB7, 0x33, 0xAD}, asf_read_unknown, 1},
    {"Payload Extension System Encryption Sample ID", {0x66, 0x98, 0xB8, 0x4E, 0x0A, 0xFA, 0x43, 0x30, 0xAE, 0xB2, 0x1C, 0x0A, 0x98, 0xD7, 0xA4, 0x4D}, asf_read_unknown, 1},
    {"Payload Extension System Degradable JPEG", {0x00, 0xE1, 0xAF, 0x06, 0x7B, 0xEC, 0x11, 0xD1, 0xA5, 0x82, 0x00, 0xC0, 0x4F, 0xC2, 0x9C, 0xFB}, asf_read_unknown, 1},
};

static int asf_read_subpayload(struct aic_asf_parser *s, struct aic_parser_packet *pkt,
                               asf_packet *asf_pkt, int is_header)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    uint8_t sub_len;

    if (is_header) {
        asf->dts_delta = aic_stream_r8(pb);
        if (asf->nb_mult_left) {
            asf->mult_sub_len = aic_stream_rl16(pb); // total
        }
        asf->sub_header_offset = aic_stream_tell(pb);
        asf->nb_sub = 0;
        asf->sub_left = 1;
    }
    sub_len = aic_stream_r8(pb);
    asf_pkt->avpkt.data = mpp_realloc(asf_pkt->avpkt.data, sub_len);
    if (!asf_pkt->avpkt.data)
        return PARSER_NOMEM;
    asf_pkt->avpkt.size = sub_len;
    asf_pkt->data_size = asf_pkt->size_left = sub_len;
    aic_stream_read(pb, asf_pkt->avpkt.data, sub_len);

    memcpy(&asf->cur_pkt, &asf_pkt->avpkt, sizeof(struct aic_parser_packet));
    memcpy(pkt, &asf_pkt->avpkt, sizeof(struct aic_parser_packet));

    asf->return_subpayload = 1;
    if (!sub_len)
        asf->return_subpayload = 0;

    if (sub_len)
        asf->nb_sub++;
    pkt->dts = asf->sub_dts + (asf->nb_sub - 1) * asf->dts_delta - asf->preroll;
    if (asf->nb_mult_left && (aic_stream_tell(pb) >=
                              (asf->sub_header_offset + asf->mult_sub_len))) {
        asf->sub_left = 0;
        asf->nb_mult_left--;
    }
    if (aic_stream_tell(pb) >= asf->packet_offset + asf->packet_size - asf->pad_len) {
        asf->sub_left = 0;
        if (!asf->nb_mult_left) {
            aic_stream_skip(pb, asf->pad_len);
            if (aic_stream_tell(pb) != asf->packet_offset + asf->packet_size) {
                if (!asf->packet_size)
                    return PARSER_INVALIDDATA;
                logw("Position %" PRId64 " wrong, should be %" PRId64 "\n",
                     (int64_t)aic_stream_tell(pb), (int64_t)(asf->packet_offset + asf->packet_size));
                aic_stream_seek(pb, asf->packet_offset + asf->packet_size, SEEK_SET);
            }
        }
    }

    return 0;
}

static void reset_packet(asf_packet *asf_pkt)
{
    asf_pkt->size_left = 0;
    asf_pkt->data_size = 0;
    asf_pkt->duration = 0;
    asf_pkt->flag = 0;
    asf_pkt->dts = 0;
    asf_pkt->duration = 0;
}

static int asf_read_replicated_data(struct aic_asf_parser *s, asf_packet *asf_pkt)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    int data_size;

    if (!asf_pkt->data_size) {
        data_size = aic_stream_rl32(pb); // read media object size
        if (data_size <= 0)
            return PARSER_INVALIDDATA;
        asf_pkt->avpkt.data = mpp_realloc(asf_pkt->avpkt.data, data_size);
        if (!asf_pkt->avpkt.data)
            return PARSER_NOMEM;
        asf_pkt->avpkt.size = data_size;
        asf_pkt->data_size = asf_pkt->size_left = data_size;
    } else {
        aic_stream_skip(pb, 4);         // reading of media object size is already done
    }
    asf_pkt->dts = aic_stream_rl32(pb); // read presentation time
    if (asf->rep_data_len >= 8)
        aic_stream_skip(pb, asf->rep_data_len - 8); // skip replicated data

    return 0;
}

static int asf_read_multiple_payload(struct aic_asf_parser *s, struct aic_parser_packet *pkt,
                                     asf_packet *asf_pkt)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    uint16_t pay_len;
    unsigned char *p;
    int ret;
    int skip = 0;

    // if replicated length is 1, subpayloads are present
    if (asf->rep_data_len == 1) {
        asf->sub_left = 1;
        asf->state = READ_MULTI_SUB;
        pkt->flag = asf_pkt->flag;
        if ((ret = asf_read_subpayload(s, pkt, asf_pkt, 1)) < 0)
            return PARSER_ERROR;
    } else {
        if (asf->rep_data_len)
            if ((ret = asf_read_replicated_data(s, asf_pkt)) < 0)
                return PARSER_ERROR;
        pay_len = aic_stream_rl16(pb); // payload length should be WORD
        if (pay_len > asf->packet_size) {
            loge("Error: invalid data packet size, pay_len %" PRIu16 ", "
                 "asf->packet_size %" PRIu32 ", offset %" PRId64 ".\n",
                 pay_len, asf->packet_size, (int64_t)aic_stream_tell(pb));
            return PARSER_INVALIDDATA;
        }
        p = asf_pkt->avpkt.data + asf_pkt->data_size - asf_pkt->size_left;
        if (pay_len > asf_pkt->size_left) {
            loge("Error: invalid buffer size, pay_len %d, data size left %d.\n",
                 pay_len, asf_pkt->size_left);
            skip = pay_len - asf_pkt->size_left;
            pay_len = asf_pkt->size_left;
        }
        if (asf_pkt->size_left <= 0)
            return PARSER_INVALIDDATA;
        if ((ret = aic_stream_read(pb, p, pay_len)) < 0)
            return PARSER_ERROR;
        if (skip)
            aic_stream_skip(pb, skip);
        asf_pkt->size_left -= pay_len;
        asf->nb_mult_left--;
    }

    return 0;
}

static int asf_read_single_payload(struct aic_asf_parser *s, asf_packet *asf_pkt)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    int64_t offset;
    uint64_t size;
    unsigned char *p;
    int ret, data_size;

    if (!asf_pkt->data_size) {
        data_size = aic_stream_rl32(pb); // read media object size
        if (data_size <= 0)
            return PARSER_EOS;
        asf_pkt->avpkt.data = mpp_realloc(asf_pkt->avpkt.data, data_size);
        if (!asf_pkt->avpkt.data)
            return PARSER_NOMEM;
        asf_pkt->data_size = asf_pkt->size_left = data_size;
    } else {
        aic_stream_skip(pb, 4);         // skip media object size
    }
    asf_pkt->dts = aic_stream_rl32(pb); // read presentation time
    if (asf->rep_data_len >= 8)
        aic_stream_skip(pb, asf->rep_data_len - 8); // skip replicated data
    offset = aic_stream_tell(pb);

    // size of the payload - size of the packet without header and padding
    if (asf->packet_size_internal)
        size = asf->packet_size_internal - offset + asf->packet_offset - asf->pad_len;
    else
        size = asf->packet_size - offset + asf->packet_offset - asf->pad_len;
    if (size > asf->packet_size) {
        loge("Error: invalid data packet size, offset %" PRId64 ".\n",
            (int64_t)aic_stream_tell(pb));
        return PARSER_INVALIDDATA;
    }
    p = asf_pkt->avpkt.data + asf_pkt->data_size - asf_pkt->size_left;
    if (size > asf_pkt->size_left || asf_pkt->size_left <= 0)
        return PARSER_INVALIDDATA;
    if (asf_pkt->size_left > size)
        asf_pkt->size_left -= size;
    else
        asf_pkt->size_left = 0;
    if ((ret = aic_stream_read(pb, p, size)) < 0)
        return PARSER_ERROR;

    if (asf->packet_size_internal)
        aic_stream_skip(pb, asf->packet_size - asf->packet_size_internal);
    aic_stream_skip(pb, asf->pad_len); // skip padding

    return PARSER_OK;
}

static int asf_read_payload(struct aic_asf_parser *s, struct aic_parser_packet *pkt)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    int ret, i;
    asf_packet *asf_pkt = NULL;

    if (!asf->sub_left) {
        uint32_t off_len, media_len;
        uint8_t stream_num;

        stream_num = aic_stream_r8(pb);
        asf->stream_index = stream_num & ASF_STREAM_NUM;
        for (i = 0; i < asf->nb_streams; i++) {
            if (asf->stream_index == asf->asf_st[i]->stream_index) {
                asf_pkt = &asf->asf_st[i]->pkt;
                asf_pkt->stream_index = asf->asf_st[i]->index;
                break;
            }
        }
        if (!asf_pkt) {
            if (asf->packet_offset + asf->packet_size <= asf->data_offset + asf->data_size) {
                if (!asf->packet_size) {
                    loge("Invalid packet size 0.\n");
                    return PARSER_INVALIDDATA;
                }
                aic_stream_seek(pb, asf->packet_offset + asf->packet_size, SEEK_SET);
                loge("Skipping the stream with the invalid stream index %d.\n",
                     asf->stream_index);
                return PARSER_INVALIDDATA;
            } else {
                return PARSER_INVALIDDATA;
            }
        }
        /*e.g: pro_flags = 0x5D,
         *     media_object_num_len_type = 0x10, so it is byte
         *     off_info_media_object_num_len_type = 0x0c, so it is dword
         *     replicated_data_len_type = 0x01, so it is byte
         */
        ASF_READ_LEN(asf->prop_flags & ASF_PL_MASK_MEDIA_OBJECT_NUMBER_LENGTH_FIELD_SIZE,
                     ASF_PL_FLAG_MEDIA_OBJECT_NUMBER_LENGTH_FIELD_, media_len);
        ASF_READ_LEN(asf->prop_flags & ASF_PL_MASK_OFFSET_INTO_MEDIA_OBJECT_LENGTH_FIELD_SIZE,
                     ASF_PL_FLAG_OFFSET_INTO_MEDIA_OBJECT_LENGTH_FIELD_, off_len);
        ASF_READ_LEN(asf->prop_flags & ASF_PL_MASK_REPLICATED_DATA_LENGTH_FIELD_SIZE,
                     ASF_PL_FLAG_REPLICATED_DATA_LENGTH_FIELD_, asf->rep_data_len);
        if (asf_pkt->size_left && (asf_pkt->frame_num != media_len)) {
            logw("Unfinished frame will be ignored\n");
            reset_packet(asf_pkt);
        }
        asf_pkt->frame_num = media_len;
        asf->sub_dts = off_len;
        if (asf->nb_mult_left) {
            if ((ret = asf_read_multiple_payload(s, pkt, asf_pkt)) < 0)
                return ret;
        } else if (asf->rep_data_len == 1) {
            asf->sub_left = 1;
            asf->state = READ_SINGLE;
            pkt->flag = asf_pkt->flag;
            if ((ret = asf_read_subpayload(s, pkt, asf_pkt, 1)) < 0)
                return ret;
        } else {
            if ((ret = asf_read_single_payload(s, asf_pkt)) < 0)
                return ret;
        }
    } else {
        for (i = 0; i <= asf->nb_streams; i++) {
            if (asf->stream_index == asf->asf_st[i]->stream_index) {
                asf_pkt = &asf->asf_st[i]->pkt;
                break;
            }
        }
        if (!asf_pkt)
            return PARSER_INVALIDDATA;
        pkt->flag = asf_pkt->flag;
        pkt->dts = asf_pkt->dts;
        // read subpayload without its header
        if ((ret = asf_read_subpayload(s, pkt, asf_pkt, 0)) < 0)
            return ret;
    }

    return 0;
}

//Read Data Packet Header
static int asf_read_packet_header(struct aic_asf_parser *s)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    uint64_t size;
    unsigned char error_flags, len_flags, pay_flags;

    asf->packet_offset = aic_stream_tell(pb);
    error_flags = aic_stream_r8(pb); // read Error Correction Flags
    if (error_flags & ASF_PACKET_FLAG_ERROR_CORRECTION_PRESENT) {
        if (!(error_flags & ASF_ERROR_CORRECTION_LENGTH_TYPE)) {
            size = error_flags & ASF_PACKET_ERROR_CORRECTION_DATA_SIZE;
            aic_stream_skip(pb, size);
        }
        len_flags = aic_stream_r8(pb);
    } else {
        len_flags = error_flags;
    }
    asf->prop_flags = aic_stream_r8(pb);
    ASF_READ_LEN(len_flags & ASF_PPI_MASK_PACKET_LENGTH_FIELD_SIZE, //Packet length type
                 ASF_PPI_FLAG_PACKET_LENGTH_FIELD_, asf->packet_size_internal);
    ASF_READ_LEN(len_flags & ASF_PPI_MASK_SEQUENCE_FIELD_SIZE,      //Sequence type
                 ASF_PPI_FLAG_SEQUENCE_FIELD_, asf->seq);
    ASF_READ_LEN(len_flags & ASF_PPI_MASK_PADDING_LENGTH_FIELD_SIZE,//Padding length type
                 ASF_PPI_FLAG_PADDING_LENGTH_FIELD_, asf->pad_len);
    asf->send_time = aic_stream_rl32(pb);                     // send time
    aic_stream_skip(pb, 2);                                   // skip duration
    asf->nb_mult_left = 0;
    if (len_flags & ASF_PPI_FLAG_MULTIPLE_PAYLOADS_PRESENT) { // Multiple Payloads present
        pay_flags = aic_stream_r8(pb);
        asf->nb_mult_left = (pay_flags & ASF_NUM_OF_PAYLOADS);// Number of Payloads
    }

    asf->nb_cur_packets++;
    return PARSER_OK;
}

static int asf_deinterleave(struct aic_asf_parser *s, asf_packet *asf_pkt, int st_num)
{
    asf_context *asf = s->priv_data;
    asf_stream *asf_st = asf->asf_st[st_num];
    unsigned char *p = asf_pkt->avpkt.data;
    uint16_t pkt_len = asf->asf_st[st_num]->virtual_pkt_len;
    uint16_t chunk_len = asf->asf_st[st_num]->virtual_chunk_len;
    int nchunks = pkt_len / chunk_len;
    struct aic_parser_packet pkt;
    int pos = 0, j, l;
    pkt.data = asf_pkt->avpkt.data;
    pkt.size = asf_pkt->data_size;
    while (asf_pkt->data_size >= asf_st->span * pkt_len + pos) {
        if (pos >= asf_pkt->data_size) {
            break;
        }
        for (l = 0; l < pkt_len; l++) {
            if (pos >= asf_pkt->data_size) {
                break;
            }
            for (j = 0; j < asf_st->span; j++) {
                if ((pos + chunk_len) >= asf_pkt->data_size)
                    break;
                memcpy(pkt.data + pos,
                       p + (j * nchunks + l) * chunk_len,
                       chunk_len);
                pos += chunk_len;
            }
        }
        p += asf_st->span * pkt_len;
        // if (p > (asf_pkt->avpkt.data + asf_pkt->data_size))
        //     break;
    }
    asf_pkt->avpkt = pkt;

    return PARSER_OK;
}

static int asf_process_state(struct aic_asf_parser *s, struct aic_parser_packet *pkt)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    int ret, i;

    switch (asf->state) {
    case READ_SINGLE:
        if (!asf->sub_left)
            asf->state = PARSE_PACKET_HEADER;
        break;
    case READ_MULTI_SUB:
        if (!asf->sub_left && !asf->nb_mult_left) {
            asf->state = PARSE_PACKET_HEADER;
            if (!asf->return_subpayload &&
                (aic_stream_tell(pb) <= asf->packet_offset +
                                            asf->packet_size - asf->pad_len))
                aic_stream_skip(pb, asf->pad_len); // skip padding
            if (asf->packet_offset + asf->packet_size > aic_stream_tell(pb))
                aic_stream_seek(pb, asf->packet_offset + asf->packet_size, SEEK_SET);
        } else if (!asf->sub_left) {
            asf->state = READ_MULTI;
        }
        break;
    case READ_MULTI:
        if (!asf->nb_mult_left) {
            asf->state = PARSE_PACKET_HEADER;
            if (!asf->return_subpayload &&
                (aic_stream_tell(pb) <= asf->packet_offset +
                                            asf->packet_size - asf->pad_len))
                aic_stream_skip(pb, asf->pad_len); // skip padding
            if (asf->packet_offset + asf->packet_size > aic_stream_tell(pb))
                aic_stream_seek(pb, asf->packet_offset + asf->packet_size, SEEK_SET);
        }
        break;
    default:
        break;
    }
    if (asf->return_subpayload) {
        asf->return_subpayload = 0;
        return 0;
    }
    for (i = 0; i < asf->nb_streams; i++) {
        asf_packet *asf_pkt = &asf->asf_st[i]->pkt;
        if (asf_pkt && !asf_pkt->size_left && asf_pkt->data_size) {
            if (asf->asf_st[i]->span > 1 &&
                asf->asf_st[i]->type == MPP_MEDIA_TYPE_AUDIO)
                if ((ret = asf_deinterleave(s, asf_pkt, i)) < 0)
                    return ret;
            memcpy(&asf->cur_pkt, &asf_pkt->avpkt, sizeof(struct aic_parser_packet));
            memcpy(pkt, &asf_pkt->avpkt, sizeof(struct aic_parser_packet));
            pkt->dts = asf_pkt->dts - asf->preroll;
            asf_pkt->data_size = 0;
            asf_pkt->frame_num = 0;
            return 0;
        }
    }

    return 1;
}

int asf_peek_packet(struct aic_asf_parser *s, struct aic_parser_packet *pkt)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    int ret;

    if (asf->is_end_packet)
        return PARSER_EOS;

    if ((aic_stream_tell(pb) >= asf->data_offset + asf->data_size) &&
        !(asf->b_flags & ASF_FLAG_BROADCAST))
        return PARSER_EOS;
    while (aic_stream_tell(pb) < aic_stream_size(pb)) {
        if (asf->state == PARSE_PACKET_HEADER) {
            asf_read_packet_header(s);
            if (aic_stream_tell(pb) >= aic_stream_size(pb))
                break;
            if (!asf->nb_mult_left)
                asf->state = READ_SINGLE;
            else
                asf->state = READ_MULTI;
        }
        ret = asf_read_payload(s, pkt);
        if (ret == PARSER_INVALIDDATA) {
            asf->state = PARSE_PACKET_HEADER;
            continue;
        } else if (ret < 0) {
            return ret;
        }

        /*process diffrent state and check if return*/
        ret = asf_process_state(s, pkt);
        if(!ret)
            return PARSER_OK;
        else if (ret < 0)
            return ret;
    }

    if (aic_stream_tell(pb) >= aic_stream_size(pb))
        return PARSER_EOS;

    return PARSER_OK;
}

int asf_read_packet(struct aic_asf_parser *s, struct aic_parser_packet *pkt)
{
    if (!pkt || !s->priv_data) {
        return PARSER_NOMEM;
    }
    asf_context *asf = s->priv_data;

    pkt->flag = 0;
    if (asf->nb_cur_packets >= asf->nb_packets && asf->nb_mult_left == 0) {
        pkt->flag = PARSER_EOS;
        asf->is_end_packet = 1;
        printf("asf is end packet, nb_cur_packets=%"PRId64", nb_packet=%"PRId64"\n",
                asf->nb_cur_packets, asf->nb_packets);
    }
    memcpy(pkt->data, asf->cur_pkt.data, pkt->size);
    return PARSER_OK;
}

static void reset_packet_state(struct aic_asf_parser *s)
{
    asf_context *asf = s->priv_data;
    int i;

    asf->state = PARSE_PACKET_HEADER;
    asf->offset = 0;
    asf->return_subpayload = 0;
    asf->sub_left = 0;
    asf->sub_header_offset = 0;
    asf->packet_offset = asf->first_packet_offset;
    asf->pad_len = 0;
    asf->rep_data_len = 0;
    asf->dts_delta = 0;
    asf->mult_sub_len = 0;
    asf->nb_mult_left = 0;
    asf->nb_sub = 0;
    asf->prop_flags = 0;
    asf->sub_dts = 0;
    for (i = 0; i < asf->nb_streams; i++) {
        asf_packet *pkt = &asf->asf_st[i]->pkt;
        pkt->size_left = 0;
        pkt->data_size = 0;
        pkt->duration = 0;
        pkt->flag = 0;
        pkt->dts = 0;
        pkt->duration = 0;
    }
}

static const guid_parser_table *find_guid(asf_guid guid)
{
    int j, ret;
    const guid_parser_table *g;

    asf_swap_guid(guid);
    g = gdef;
    for (j = 0; j < MPP_ARRAY_ELEMS(gdef); j++) {
        if (!(ret = memcmp(guid, g->guid, sizeof(g->guid))))
            return g;
        g++;
    }

    return NULL;
}

static int detect_unknown_subobject(struct aic_asf_parser *s, int64_t offset, int64_t size)
{
    asf_context *asf = s->priv_data;
    struct aic_stream *pb = s->stream;
    const guid_parser_table *g = NULL;
    asf_guid guid;
    int ret;

    if (offset > INT64_MAX - size)
        return PARSER_INVALIDDATA;

    while (aic_stream_tell(pb) <= offset + size) {
        if (aic_stream_tell(pb) == asf->offset)
            break;
        asf->offset = aic_stream_tell(pb);
        if ((ret = asf_get_guid(pb, &guid)) < 0)
            return ret;
        g = find_guid(guid);
        if (g) {
            if ((ret = g->read_object(s, g)) < 0)
                return ret;
        } else {
            guid_parser_table g2;

            g2.name = "Unknown";
            g2.is_subobject = 1;
            asf_read_unknown(s, &g2);
        }
    }

    return PARSER_OK;
}


int asf_seek_packet(struct aic_asf_parser *s, s64 pts)
{
    reset_packet_state(s);
    return PARSER_ERROR;
}

int asf_read_header(struct aic_asf_parser *s)
{
    asf_context *asf = NULL;
    struct aic_stream *pb = s->stream;
    const guid_parser_table *g = NULL;
    asf_guid guid;
    int ret;
    uint64_t size;

    s->priv_data = mpp_alloc(sizeof(struct asf_context));
    if (!s->priv_data) {
        loge("malloc for flv_context failed.\n");
        return PARSER_NOMEM;
    }
    memset(s->priv_data, 0, sizeof(struct asf_context));
    asf = s->priv_data;

    asf->preroll = 0;
    asf->is_simple_index = 0;
    asf_get_guid(pb, &guid);
    if (memcmp(&guid, &g_asf_header, sizeof(asf_guid)))
        return PARSER_INVALIDDATA;
    aic_stream_skip(pb, 8); // skip header object size
    aic_stream_skip(pb, 6); // skip number of header objects and 2 reserved bytes
    asf->data_reached = 0;

    /* 1  is here instead of pb->eof_reached because (when not streaming), Data are skipped
     * for the first time,
     * Index object is processed and got eof and then seeking back to the Data is performed.
     */
    while (1) {
        // for the cases when object size is invalid
        if (aic_stream_tell(pb) == asf->offset)
            break;
        asf->offset = aic_stream_tell(pb);
        if ((ret = asf_get_guid(pb, &guid)) < 0) {
            if (ret == PARSER_EOS && asf->data_reached)
                break;
            else
                goto failed;
        }
        g = find_guid(guid);
        if (g) {
            asf->unknown_offset = asf->offset;
            asf->is_header = 1;
            if ((ret = g->read_object(s, g)) < 0)
                goto failed;
        } else {
            size = aic_stream_rl64(pb);
            align_position(pb, asf->offset, size);
        }

        if (asf->data_reached)
            break;
    }

    if (!asf->data_reached) {
        loge("Data Object was not found.\n");
        ret = PARSER_INVALIDDATA;
        goto failed;
    }

    return PARSER_OK;

failed:
    if (s->priv_data) {
        mpp_free(s->priv_data);
        s->priv_data = NULL;
    }
    return PARSER_ERROR;
}


int asf_read_close(struct aic_asf_parser *s)
{
    int i = 0;
    asf_context *asf = NULL;
    struct asf_stream_ctx *st = NULL;

    for (i = 0; i < s->nb_streams; i++) {
        st = s->streams[i];
        if (!st)
            continue;

        if (st->codecpar.extradata)
            mpp_free(st->codecpar.extradata);

        mpp_free(st);
    }

    if (!s->priv_data)
        return PARSER_ERROR;

    asf = s->priv_data;
    for (i = 0; i < asf->nb_streams; i++) {
        if (asf->asf_st[i]) {
            if (asf->asf_st[i]->pkt.avpkt.data)
                mpp_free(asf->asf_st[i]->pkt.avpkt.data);
            mpp_free(asf->asf_st[i]);
        }
    }
    mpp_free(s->priv_data);
    s->priv_data = NULL;
    return PARSER_OK;
}
